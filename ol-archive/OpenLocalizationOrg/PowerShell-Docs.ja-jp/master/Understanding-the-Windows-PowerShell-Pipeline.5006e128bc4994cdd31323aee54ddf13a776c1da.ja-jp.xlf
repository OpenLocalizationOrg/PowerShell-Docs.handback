<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d90bf940a1047b629f7b59d239aab50a78748251</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\fundamental\Understanding-the-Windows-PowerShell-Pipeline.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4596d53681efc5caf3aed6b766a290d2b73c29e6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">42e5e71ea55e5a362408cc4f04638d1e4925dbf3</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Windows PowerShell パイプラインを理解する</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">PowerShell, コマンドレット</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Windows PowerShell パイプラインを理解する</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Piping works virtually everywhere in Windows PowerShell.</source>
          <target state="translated">Windows PowerShell では、パイプ処理をほぼすべての状況で使用できます。</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Although you see text on the screen, Windows PowerShell does not pipe text between commands.</source>
          <target state="translated">画面にはテキストが表示されますが、コマンド間で受け渡しされる情報はテキストではありません。</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Instead, it pipes objects.</source>
          <target state="translated">パイプの中を流れるデータは、実際にはオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The notation used for pipelines is similar to that used in other shells, so at first glance, it may not be apparent that Windows PowerShell introduces something new.</source>
          <target state="translated">パイプラインで使う表記は他のシェルで使う表記に似ているため、一見すると、Windows PowerShell で何かが新しく導入されたことがわかりにくい可能性があります。</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For example, if you use the <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet to force a page-by-page display of output from another command, the output looks just like the normal text displayed on the screen, broken up into pages:</source>
          <target state="translated">たとえば、<bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> コマンドレットを使用して、別のコマンドからの出力をページ単位で表示させると、通常のテキストがページごとに分割されて画面上に表示されているだけのように見えます。</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Out-Host -Paging command is a useful pipeline element whenever you have lengthy output that you would like to display slowly.</source>
          <target state="translated">Out-Host -Paging コマンドは、長大な出力結果を少しずつ表示したい場合に役立つパイプライン要素です。</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It is especially useful if the operation is very CPU-intensive.</source>
          <target state="translated">特に、CPU への負荷がきわめて大きい処理で使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Because processing is transferred to the Out-Host cmdlet when it has a complete page ready to display, cmdlets that precede it in the pipeline halt operation until the next page of output is available.</source>
          <target state="translated">処理は 1 ページ分を表示する準備が整った段階で Out-Host コマンドレットに渡されるため、パイプラインにおける直前のコマンドレットは、次のページの出力の用意ができるまで処理を中断します。</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can see this if you use the Windows Task Manager to monitor CPU and memory use by Windows PowerShell.</source>
          <target state="translated">このことは、Windows PowerShell による CPU およびメモリの使用状況を Windows タスク マネージャーで監視するとわかります。</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Run the following command: <bpt id="p1">**</bpt>Get-ChildItem C:\\Windows -Recurse<ept id="p1">**</ept>.</source>
          <target state="translated">次のコマンドを実行します。 <bpt id="p1">**</bpt>Get-childitem C:\\Windows-Recurse<ept id="p1">**</ept>します。</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Compare the CPU and memory usage to this command: <bpt id="p1">**</bpt>Get-ChildItem C:\\Windows -Recurse | Out-Host -Paging<ept id="p1">**</ept>.</source>
          <target state="translated">このコマンドに CPU とメモリの使用状況の比較: <bpt id="p1">**</bpt>Get-childitem C:\\Windows-Recurse |Out-host-Paging<ept id="p1">**</ept>します。</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What you see on the screen is text, but that is because it is necessary to represent objects as text in a console window.</source>
          <target state="translated">画面に表示されるのはテキストですが、これは、コンソール ウィンドウに表示するためには、オブジェクトをテキストで表す必要があるためです。</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This is just a representation of what is really going on inside Windows PowerShell.</source>
          <target state="translated">これは、Windows PowerShell 内部で実際に行われていることを表現するための 1 つの手段にすぎません。</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, consider the Get-Location cmdlet.</source>
          <target state="translated">Get-Location コマンドレットを例に考えてみます。</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you type <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> while your current location is the root of the C drive, you would see the following output:</source>
          <target state="translated">現在の場所が C ドライブのルートである場合に、<bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> と入力すると、次のような出力結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If Windows PowerShell pipelined text, issuing a command such as <bpt id="p1">**</bpt>Get-Location | Out-Host<ept id="p1">**</ept>, would pass from <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Out-Host<ept id="p3">**</ept> a set of characters in the order they are displayed onscreen.</source>
          <target state="translated">パイプラインを流れるデータがテキストだとした場合、<bpt id="p1">**</bpt>Get-Location | Out-Host<ept id="p1">**</ept> というコマンドを実行すると、<bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> から <bpt id="p3">**</bpt>Out-Host<ept id="p3">**</ept> には、一連の文字が、画面に表示される順番で渡されます。</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In other words, if you were to ignore the heading information, <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> would first receive the character '<bpt id="p2">**</bpt>C'<ept id="p2">**</ept>, then the character '<bpt id="p3">**</bpt>:'<ept id="p3">**</ept>, then the character '<bpt id="p4">**</bpt>\\'<ept id="p4">**</ept>.</source>
          <target state="translated">つまり見出しの情報を無視する場合は、 <bpt id="p1">**</bpt>Out-host<ept id="p1">**</ept> 文字が最初に受信 '<bpt id="p2">**</bpt>C'<ept id="p2">**</ept>, 、文字、'<bpt id="p3">**</bpt>:'<ept id="p3">**</ept>, 、文字、'<bpt id="p4">**</bpt>\\'<ept id="p4">**</ept>します。</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet could not determine what meaning to associate with the characters output by the <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> cmdlet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> コマンドレットは、<bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> コマンドレットによって出力された文字にどの意味を関連付けるかを判断できません。</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Instead of using text to let commands in a pipeline communicate, Windows PowerShell uses objects.</source>
          <target state="translated">Windows PowerShell では、パイプラインのコマンド間でデータを受け渡すのに、テキストではなくオブジェクトが使用されています。</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>From the standpoint of a user, objects package related information into a form that makes it easier to manipulate the information as a unit, and extract specific items that you need.</source>
          <target state="translated">ユーザーの立場から見ると、関連する情報がオブジェクトとしてパッケージ化されることにより、情報が扱いやすい単位でまとめられ、必要に応じて特定の項目だけを抽出できるという利点があります。</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> command does not return text that contains the current path.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> コマンドは、現在のパスを表すテキストを返すわけではありません。</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It returns a package of information called a <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> object that contains the current path along with some other information.</source>
          <target state="translated">実際に返されるのは、<bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> オブジェクトという情報のパッケージです。このオブジェクトには、現在のパスだけでなく、他の情報も一緒に格納されています。</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet then sends this <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> object to the screen, and Windows PowerShell decides what information to display and how to display it based on its formatting rules.</source>
          <target state="translated">この <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> オブジェクトが <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> コマンドレットによって画面に送られると、Windows PowerShell は、どの情報をどのように表示するかを書式ルールに基づいて決定します。</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In fact, the heading information output by the <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> cmdlet is added only at the end of the process, as part of the process of formatting the data for onscreen display.</source>
          <target state="translated">実際、<bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> コマンドレットによって出力される見出し情報は、処理の最後になって初めて、画面表示用にデータを書式設定するプロセスの一部として追加されます。</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>What you see onscreen is a summary of information, and not a complete representation of the output object.</source>
          <target state="translated">ユーザーが画面で確認できるのは情報の要約であり、出力されたオブジェクトの完全な表現ではありません。</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Given that there may be more information output from a Windows PowerShell command than what we see displayed in the console window, how can you retrieve the non-visible elements?</source>
          <target state="translated">Windows PowerShell のコマンドから、コンソール ウィンドウに表示されている以上の情報が出力されているとすれば、見えない要素を取得するにはどうすればよいのかという疑問が残ります。</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>How do you view the extra data?</source>
          <target state="translated">つまり、残りのデータを表示するにはどうすればよいか、</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>And what if you want to view the data in a format different than the one Windows PowerShell normally uses?</source>
          <target state="translated">また、Windows PowerShell で通常使用される表示形式とは異なる形式でデータを表示するにはどうすればよいのかという点です。</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The rest of this chapter discusses how you can discover the structure of specific Windows PowerShell objects, selecting specific items and formatting them for easier display, and how to send this information to alternative output locations such as files and printers.</source>
          <target state="translated">この章の残りの部分では、特定の Windows PowerShell オブジェクトの構造を調べる方法、特定の項目を選んで見やすいように書式化する方法、この情報を他の出力場所 (ファイルやプリンターなど) に送る方法について説明します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>