<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="de-de">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">94117fcf337ecf550d6df1d167e608ba64582c03</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Removing-Objects-from-the-Pipeline--Where-Object-.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0f0a30bc86fa9c9eeed62a99cdbcf6a4e50c1d33</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">41ca3559dd3ce0334ea64597c1b412608524b7cb</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline  Where Object</source>
          <target state="translated">Entfernen von Objekten aus der Pipeline  Where-Object</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline (Where-Object)</source>
          <target state="translated">Entfernen von Objekten aus der Pipeline (Where-Object)</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, you often generate and pass along more objects to a pipeline than you want.</source>
          <target state="translated">In Windows PowerShell geschieht es häufig, dass Sie mehr Objekte als gewünscht generieren und an eine Pipeline übergeben.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can specify the properties of particular objects to display by using the <bpt id="p1">**</bpt>Format<ept id="p1">**</ept> cmdlets, but this does not help with the problem of removing entire objects from the display.</source>
          <target state="translated">Mithilfe der <bpt id="p1">**</bpt>Format<ept id="p1">**</ept>-Cmdlets können Sie die Eigenschaften bestimmter Objekte angeben, die angezeigt werden sollen, aber dies hilft dabei, ganze Objekte aus der Anzeige zu entfernen.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You may want to filter objects before the end of a pipeline, so you can perform actions on only a subset of the initially-generated objects.</source>
          <target state="translated">Möglicherweise möchten Sie die Objekte vor dem Ende einer Pipeline filtern, um nur für eine Teilmenge der ursprünglich generierten Objekte bestimmte Aktionen auszuführen.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Windows PowerShell includes a <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept> cmdlet that allows you to test each object in the pipeline and only pass it along the pipeline if it meets a particular test condition.</source>
          <target state="translated">Windows PowerShell enthält ein <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept>-Cmdlet, mit dem Sie jedes Objekt in der Pipeline testen können, um es nur dann an die Pipeline zu übergeben, wenn es eine bestimmte Testbedingung erfüllt.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Objects that do not pass the test are removed from the pipeline.</source>
          <target state="translated">Objekte, die den Test nicht bestehen, werden aus der Pipeline entfernt.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You supply the test condition as the value of the <bpt id="p1">**</bpt>Where-ObjectFilterScript<ept id="p1">**</ept> parameter.</source>
          <target state="translated">Sie geben die Testbedingung als Wert des Parameters <bpt id="p1">**</bpt>Where-ObjectFilterScript<ept id="p1">**</ept> an.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Performing Simple Tests with Where-Object</source>
          <target state="translated">Ausführen einfacher Tests mit „Where-Object“</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept> is a <bpt id="p2">*</bpt>script block<ept id="p2">*</ept> -  one or more Windows PowerShell commands surrounded by braces {} - that evaluates to true or false.</source>
          <target state="translated">Der Wert von <bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept> ist ein <bpt id="p2">*</bpt>Skriptblock<ept id="p2">*</ept> (d.h. ein oder mehrere, in geschweifte Klammern {} eingeschlossene Windows PowerShell-Befehle), der als „true“ oder „false“ ausgewertet wird.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>These script blocks can be very simple, but creating them requires knowing about another Windows PowerShell concept, comparison operators.</source>
          <target state="translated">Diese Skriptblöcke können sehr einfach sein, aber ihre Erstellung erfordert Kenntnisse eines anderen Windows PowerShell-Konzepts: Vergleichsoperatoren.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A comparison operator compares the items that appear on each side of it.</source>
          <target state="translated">Mit einem Vergleichsoperator werden die Elemente auf den beiden Seiten des Operators verglichen.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Comparison operators begin with a '-' character and are followed by a name.</source>
          <target state="translated">Vergleichsoperatoren beginnen mit einem Minuszeichen (-), gefolgt von einem Namen.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Basic comparison operators work on almost any kind of object.</source>
          <target state="translated">Die grundlegenden Vergleichsoperatoren können für nahezu jede Art von Objekt verwendet werden.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The more advanced comparison operators might only work on text or arrays.</source>
          <target state="translated">Die erweiterten Vergleichsoperatoren können möglicherweise nur mit Text oder Arrays verwendet werden.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>By default, when working with text, Windows PowerShell comparison operators are case-insensitive.</source>
          <target state="translated">Bei Windows PowerShell-Vergleichsoperatoren wird beim Arbeiten mit Text die Groß-/Kleinschreibung standardmäßig nicht beachtet.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Due to parsing considerations, symbols such as &lt;,&gt;, and = are not used as comparison operators.</source>
          <target state="translated">Aufgrund von Analyseaspekten werden Symbole wie &lt;, &gt; und = nicht als Vergleichsoperatoren verwendet.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Instead, comparison operators are comprised of letters.</source>
          <target state="translated">Stattdessen bestehen Vergleichsoperatoren aus Buchstaben.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The basic comparison operators are listed in the following table.</source>
          <target state="translated">In der folgenden Tabelle sind die grundlegenden Vergleichsoperatoren aufgeführt.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Comparison Operator</source>
          <target state="translated">Vergleichsoperator</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Bedeutung</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">Beispiel (gibt „true“ zurück)</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>-eq</source>
          <target state="translated">-eq</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>is equal to</source>
          <target state="translated">Ist gleich</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>1 -eq 1</source>
          <target state="translated">1 -eq 1</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>-ne</source>
          <target state="translated">-ne</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Is not equal to</source>
          <target state="translated">Ist ungleich</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>1 -ne 2</source>
          <target state="translated">1 -ne 2</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-lt</source>
          <target state="translated">-lt</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Is less than</source>
          <target state="translated">Ist kleiner als</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>1 -lt 2</source>
          <target state="translated">1 -lt 2</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>-le</source>
          <target state="translated">-le</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Is less than or equal to</source>
          <target state="translated">Ist kleiner als oder gleich</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>1 -le 2</source>
          <target state="translated">1 -le 2</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>-gt</source>
          <target state="translated">-gt</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Is greater than</source>
          <target state="translated">Ist größer als</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>2 -gt 1</source>
          <target state="translated">2 -gt 1</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>-ge</source>
          <target state="translated">-ge</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Is greater than or equal to</source>
          <target state="translated">Ist größer als oder gleich</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>2 -ge 1</source>
          <target state="translated">2 -ge 1</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>-like</source>
          <target state="translated">-like</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Is like (wildcard comparison for text)</source>
          <target state="translated">Entspricht (Platzhaltervergleich für Text)</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>"file.doc" -like "f\*.do?"</source>
          <target state="translated">"entweder"-wie "F\ * intensive?"</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>-notlike</source>
          <target state="translated">-notlike</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Is not like (wildcard comparison for text)</source>
          <target state="translated">Entspricht nicht (Platzhaltervergleich für Text)</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>"file.doc" -notlike "p\*.doc"</source>
          <target state="translated">"entweder"-notlike "P\ * .doc"</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>-contains</source>
          <target state="translated">-contains</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Enthält</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>1,2,3 -contains 1</source>
          <target state="translated">1,2,3 -contains 1</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>-notcontains</source>
          <target state="translated">-notcontains</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Does not contain</source>
          <target state="translated">Enthält nicht</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>1,2,3 -notcontains 4</source>
          <target state="translated">1,2,3 -notcontains 4</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Where-Object script blocks use the special variable '$_' to refer to the current object in the pipeline.</source>
          <target state="translated">In „Where-Object“-Skriptblöcken dient die spezielle Variable „$_“ zum Verweisen auf das aktuelle Objekt in der Pipeline.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Here is an example of how it works.</source>
          <target state="translated">Es folgt ein Beispiel für die Funktionsweise.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If you have a list of numbers, and only want to return the ones that are less than 3, you can use Where-Object to filter the numbers by typing:</source>
          <target state="translated">Wenn Sie über eine Liste mit Zahlen verfügen und nur diejenigen zurückgegeben möchten, die kleiner als 3 sind, können Sie die Zahlen mit „Where-Object“ folgendermaßen filtern:</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Filtering Based on Object Properties</source>
          <target state="translated">Filtern basierend auf Objekteigenschaften</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Since $_ refers to the current pipeline object, we can access its properties for our tests.</source>
          <target state="translated">Da „$_“ auf das aktuelle Pipelineobjekt verweist, können wir für unsere Tests auf seine Eigenschaften zugreifen.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>As an example, we can look at the Win32_SystemDriver class in WMI.</source>
          <target state="translated">Als Beispiel können wir uns die Klasse „Win32_SystemDriver“ in WMI anschauen.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>There might be hundreds of system drivers on a particular system, but you might only be interested in a particular set of the system drivers, such as those which are currently running.</source>
          <target state="translated">Möglicherweise gibt es in einem bestimmten System Hunderte von Systemtreibern, Sie sind aber vielleicht nur an einer bestimmten Auswahl von Systemtreibern interessiert, z. B. an den Treibern, die gerade ausgeführt werden.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If you use Get-Member to view Win32_SystemDriver members (<bpt id="p1">**</bpt>Get-WmiObject -Class Win32_SystemDriver | Get-Member -MemberType Property<ept id="p1">**</ept>) you will see that the relevant property is State, and that it has a value of "Running" when the driver is running.</source>
          <target state="translated">Wenn Sie „Get-Member“ verwenden, um „Win32_SystemDriver“-Elemente anzuzeigen (<bpt id="p1">**</bpt>Get-WmiObject -Class Win32_SystemDriver | Get-Member -MemberType Property<ept id="p1">**</ept>) sehen Sie, dass die relevante Eigenschaft „State“ ist und den Wert „Running“ aufweist, wenn der Treiber ausgeführt wird.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You can filter the system drivers, selecting only the running ones by typing:</source>
          <target state="translated">Sie können die Systemtreiber so filtern, dass nur die ausgeführten Treiber ausgewählt werden. Geben Sie dazu Folgendes ein:</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This still produces a long list.</source>
          <target state="translated">Dies erzeugt immer noch eine lange Liste.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You may want to filter to only select the drivers set to start automatically by testing the StartMode value as well:</source>
          <target state="translated">Möglicherweise möchten Sie die Liste weiter filtern, um nur die Treiber auszuwählen, die automatisch gestartet werden. Verwenden Sie dazu außerdem den „StartMode“-Wert:</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This gives us a lot of information we no longer need because we know that the drivers are running.</source>
          <target state="translated">Dadurch erhalten Sie eine Vielzahl von Informationen, die Sie nicht mehr benötigen, da bekannt ist, dass die Treiber ausgeführt werden.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In fact, the only information we probably need at this point are the name and the display name.</source>
          <target state="translated">In der Tat sind die einzigen Informationen, die Sie an dieser Stelle wahrscheinlich benötigen, der Name und der Anzeigename.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following command includes only those two properties, resulting in much simpler output:</source>
          <target state="translated">Der folgende Befehl enthält nur diese zwei Eigenschaften, wodurch eine wesentlich vereinfachte Ausgabe erzeugt wird:</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>There are two Where-Object elements in the above command, but they can be expressed in a single Where-Object element by using the -and logical operator, like this:</source>
          <target state="translated">Der oben stehende Befehl enthält zwei „Where-Object“-Elemente, die aber mit Hilfe des logischen Operators „-and“ wie folgt in einem einzigen „Where-Object“-Element ausgedrückt werden können:</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The standard logical operators are listed in the following table.</source>
          <target state="translated">In der folgenden Tabelle sind die standardmäßigen logischen Operatoren aufgeführt.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Logical Operator</source>
          <target state="translated">Logischer Operator</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Bedeutung</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">Beispiel (gibt „true“ zurück)</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>-and</source>
          <target state="translated">-and</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Logical and; true if both sides are true</source>
          <target state="translated">Logisches „Und“; „true“, wenn beide Seiten zutreffen</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>(1 -eq 1) -and (2 -eq 2)</source>
          <target state="translated">(1 -eq 1) -and (2 -eq 2)</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-or</source>
          <target state="translated">-or</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Logical or; true if either side is true</source>
          <target state="translated">Logisches „Oder“; „true“, wenn eine der beiden Seiten zutrifft</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>(1 -eq 1) -or (1 -eq 2)</source>
          <target state="translated">(1 -eq 1) -or (1 -eq 2)</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>-not</source>
          <target state="translated">-not</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">Logisches „Nicht“; kehrt „true“ und „false“ um</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>-not (1 -eq 2)</source>
          <target state="translated">-not (1 -eq 2)</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>\!</source>
          <target state="translated">\!</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">Logisches „Nicht“; kehrt „true“ und „false“ um</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>\!(1 -eq 2)</source>
          <target state="translated">\! (1 - Eq 2)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>